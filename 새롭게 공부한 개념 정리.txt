# 1000

- map(function, iterable)
iterable에 여러개의 리스트가 있을텐데, 거기에 funciton 을 각각 적용 가능
내부적으로 C로 구현되어 있으므로 파이썬 반복문보다 빠름
제약 사항 : 입력된 모든 이터레이터 객체의 길이가 같아야 함

- sep="??"
print 함수의 sep 매개변수를 사용하면 출력할 값들 사이의 구분자를 지정할 수 있음
ex) 
>>> print("2025", "08", "17", sep="-")
2025-08-17

- print 방법론
1. 문자열 띄어쓰기는 쉼표로 한다.
ex)
>>> print("life", "is", "too short")
life is too short
2. 한줄에 계속 이어서 출력하려면 매개변수 end를 사용한다.
(일반적인 프린트는 end='/n' 이 생략되어 있다고 봐도 됨)
ex)
>>> for i in range(10):
...     print(i, end=' ')
0 1 2 3 4 5 6 7 8 9
3. f 문자열 포맷 이용 가능 : print(f"{abc}")
ex) 
>>> x = 3.141592
>>> print(f"x : {x:.4f}")
x : 3.1416

- split()
1. split() : 띄어쓰기, 엔터를 구분하여 split
2. split('구분자') : 구분자를 기준으로 split


# 15552

- readline()
이제는 여러개의 input 을 받아올 때 그냥 input() 으로 받아와서는 시간 초과가 날 수 있다.
그래서 readline 을 사용하기로 한다. 사용을 위해서는 sys 를 import 한다.
단, 이때는 맨 끝의 개행문자까지 같이 입력받기 때문에, 
문자열을 저장할 경우에는 꼭 .rstrip()을 추가해주도록 한다.
ex)
import sys
char_a = sys.stdin.readline().rstrip()
a, b, c = map(int, sys.stdin.readline().split())


# 10951

- try, except
코드는 무조건 끝나야 함. 아니면 런타임 오류가 나게 되어 있음.
따라서, input 을 계속 받다가 안들어오면 끝내는 코드는 아래와 같이 하면 됨.
ex)
while True:
    try:
        a = input()
    except:
        break


# 번외

- 문자열 정렬
정렬은 다음과 같이 할 수 있다.
>>> f'{"hi":<10}'  # 왼쪽 정렬
'hi        '
>>> f'{"hi":>10}'  # 오른쪽 정렬
'        hi'
>>> f'{"hi":^10}'  # 가운데 정렬
'    hi    '
공백 채우기는 다음과 같이 할 수 있다.
>>> f'{"hi":=^10}'  # 가운데 정렬하고 '=' 문자로 공백 채우기
'====hi===='
>>> f'{"hi":!<10}'  # 왼쪽 정렬하고 '!' 문자로 공백 채우기
'hi!!!!!!!!'


# 10807

- 문자열 관련 함수들
1) a.count('b') : 문자열 a에서 b의 갯수를 리턴
2) a.find('b') : 문자열 a에서 b가 처음으로 나오는 index를 리턴, 없을 경우 -1 리턴
3) a.index('b') : find 와 동일하나 b가 없는 경우에 Error
4) ",".join('abcd') : abcd 사이에 , 를 삽입 -> a,b,c,d
5) a.upper() : 문자열 a를 모두 대문자로 변경
6) a.lower() : 문자열 a를 모두 소문자로 변경
7) a.lstrip() : 문자열 a의 왼쪽 공백 지워줌
8) a.rstrip() : 문자열 a의 오른쪽 공백 지워줌
9) a.strip() : 문자열 a의 양쪽 공백 지워줌
10) a.replace("abc", "abcd") : 문자열 a에 포함된 abc를 abcd 로 변경
11) a.split() : 문자열 나누기
12) a.isalpha() : 문자열이 알파벳으로만 구성되어 있는지 확인 후 True/False 리턴
13) a.isdigit() : 문자열이 숫자로만 구성되어 있는지 확인 후 True/False 리턴
14) a.startswith("bcd") : 문자열 a가 bcd로 시작하는지 검사 후 True/False 리턴
15) a.endswith("bcd") : 문자열 a가 bcd로 끝나는지 검사 후 True/False 리턴


# 10813

temp = basket[i-1]
basket[i-1] = basket[j-1]
basket[j-1] = temp
위의 과정을 아래와 같이 한줄로 적을 수 있다.
basket[i-1], basket[j-1] = basket[j-1], basket[i-1]

- 리스트 언패킹 : *
basket = [1, 2, 3, 4, 5] 이라는 리스트가 있을 때,
앞에 '*'을 붙여서 print 하면 리스트 안의 요소들을 각각 꺼내서 전달함
ex)
>> print(*basket)
>> 1 2 3 4 5
응용으로 print(*basket, sep=', ') 로 하면 1, 2, 3, 4, 5 의 결과를 얻을 수도 있음



# 5597

- set : 수학의 집합 개념을 코드로 구현한 자료형
* 2대 핵심 특징
1) 중복을 허용하지 않는다. (똑같은 값을 여러번 넣어도 결국 하나만 남음)
2) 순서가 없다. (인덱싱으로 값을 꺼낼 수 없다)
* my_set = set(my_list) 형태로 set 만들 수 있음.
이후, 집합 연산하듯이 하면 됨.
1) 교집합 (sample_set & my_set) : 둘 다 있는 것
2) 합집합 (sample_set | my_set) : 합친 것
3) 차집합 (sample_set - my_set) : sample_set 에만 있는 것
* 데이터 추가 및 삭제
1) my_set.add(4) : my_set 에 값 4를 추가
2) my_set.update([5,6]) : my_set 에 리스트를 넣어 한꺼번에 추가
3) my_set.remove(1) : my_set 에서 값 1을 삭제
* 꿀팁
1) 중복 제거 필요할 때 list(set(my_list)) 로 한번에 가능
2) if x in my_list 라고 하면 연산 느린데, if x in my_set 으로 하면 개빠름
3) sorted(my_set) 을 사용하면 my_set 을 정렬하고 리스트로 바꿔준다!! 개꿀
- list(range(a,b))로 a에서 b-1 로 구성된 list 만들 수 있다. set도 동일


# 10811

- list 관련 함수
1) a.append(b) : list a에 b추가
2) a.sort() : list a 를 오름차순 정렬
3) a.reverse() : list a 를 역순으로 뒤집음 
4) a.index(x) : list a 에서 x의 위치를 반환 (존재 안하면 Error)
5) a.insert(x, y) : list a 의 x 위치에 y를 삽입
6) a.remove(x) : list a 에서 첫번째로 나오는 x를 삭제
7) a.pop() : list a의 맨 마지막 요소를 반환하고 그 요소를 삭제
8) a.count(x) : list a 안에 x가 몇개 들어있는지 반환
9) a.extend([b, c]) : list a 에 list [b, c]를 이어붙임

- 뒤에서 부터 거꾸로 읽는 팁 : [::-1]
ex) a[0:4][::-1] -> list a의 0~3번 인덱스 값을 뒤에서 부터 한칸씩 슬라이싱


# 1546
- 몰랐던/헷갈렸던 내장 함수
1) all() : 괄호안의 리스트 중 하나라도 0이면 False, 비어있으면 True
2) any() : 괄호안의 리스트 중 하나라도 0이 아니면 True, 비어있으면 False
3) chr() : 유니코드 숫자를 입력받아 그 코드에 해당하는 문자를 반환
ex) chr(97) : 'a'
4) dir() : 객체가 지닌 변수나 함수를 보여주는 함수.. 생각 안날 때 이거 개꿀인듯
ex) >>> dir([1, 2, 3])
['append', 'count', 'extend', 'index', 'insert', 'pop',...]
5) divmod(a, b) : a를 b로 나눈 몫과 나머지를 튜플로 반환
6) filter(함수, 반복 가능한 데이터) : 함수가 참이 되는 데이터만 반환
ex) def positive(x):
    return x > 0
    print(list(filter(positive, [1, -3, 2, 0, -5, 6])))
-> [1, 2, 6]
7) pow(x,y) : x를 y제곱한 결과를 반환
8) range(a,b,c) : a이상 b미만에서 간격 c를 기준으로
9) round(a, b) : a를 입력받아 소수점 b째 자리까지 반올림
10) sorted(iterable) : iterable 데이터를 정렬한 후 리스트로 반환


# 1316
- word.find 로 정렬하면 정렬결과가 원래와 같도록 같은 문자끼리 모을 수 있음
ex) sorted(word, key=word.find)
>> word = 'aabsddeadas'
>> print(sorted(word))
['a', 'a', 'a', 'a', 'b', 'd', 'd', 'd', 'e', 's', 's']
>> print(sorted(word, key=word.find))
['a', 'a', 'a', 'a', 'b', 's', 's', 'd', 'd', 'd', 'e']


# 25206
- 딕셔너리 : a = {'x' : 3, 'y' : 5} 등으로 구성해서 딕셔너리 정의 가능
해당 내용을 불러올때는 a('x') 와 같은식으로 불러올 수 있다.
** 대괄호가 아닌 중괄호를 쓰고 있음에 유의!!
ex) xy_dic = {
    'x' : 1, 'y' : 2,
    3 : 'z'
}
>> print(xy_dic['x'])
1
>> print(xy_dic[3])
z


# 2563
- 얕은 복사 (list 복사시 주의해야 함!!)
paper_row = [0 for _ in range(100)]
paper = [paper_row for _ in range(100)]
위와 같이 선언할 경우.. 동일한 paper_row 리스트 하나를 5번 참조하게 된다...
즉 paper 가 각자 독립된 주소를 갖는 것이 아니라,
똑같은 paper_row 를 100개 가지는 것이기 때문에 한 줄만 바꾸려고 해도 100줄이 다 바뀐다..
(paper[0], ... paper[99] 가 모두 같은 주소값을 가진다고 생각하면 됨)

때에 따라 얕은 복사가 필요할 수도 있기는 하지만,
그런 경우가 아니라면, 꼭 주의해서 사용해야 함. 아래와 같이 할 수 있음
paper = [[0 for _ in range(100)] for _ in range(100)]


# 2745
- 진법 변환
int(n, b) : b진법 수 n을 10진수로 변환...
이때 n은 string 이어야 하고, b는 int 여야 한다.
ex) print(int('1001', 2)) --> 9


# 11005
- 일반인들이 자주 쓰는 변수 이름 (변수 이름 정하기 어려울 때 참고)
idx	(Index)	리스트나 배열의 인덱스(순번)
cnt	(Count)	개수를 셀 때
tmp/temp (Temporary) 잠시 값을 담아두는 임시 변수
cur	(Current) 현재 가리키고 있는 위치나 값
arr	(Array)	배열 (파이썬에서는 주로 리스트)
prev (Previous)	이전 단계의 값
res (Result) 결과
digits (Digit) 자릿수


# 2581
- 약수의 갯수를 구할 때 전체로 하면 시간이 너무 오래 걸리니까,
제곱근까지의 약수의 갯수만을 구해도 된다. 왜냐면 어차피 약수라는게 짝을 짓고 있기 때문



# 24262
- 시간 복잡도
입력값 n의 크기에 따라 알고리즘이 얼마나 오래 걸리는지 나타내는 척도
이 문제처럼 n에 상관없이 일정한 시간이 걸리면 **상수 시간(Constant Time)**이라고 한다.

- 빅오 표기법
알고리즘의 효율성을 수학적으로 표현하는 방법.
O(1): n이 늘어나도 작업량은 그대로
O(n): <for i in range(n)> 처럼 n에 비례해서 늘어나는 경우 (차수는 1)
O(n^2): 이중 반복문처럼 n의 제곱에 비례해서 늘어나는 경우 (차수는 2).

- 알고리즘의 차수
수행 횟수를 식으로 나타냈을 때 가장 큰 지수


# 브루트 포스 알고리즘 (Brute : 단순히, Force : 힘)
- 완전 탐색 알고리즘. 나올 수 있는 모든 경우의 수를 다 해보는 것
- 어떻게?
1) for 또는 while loop 활용
2) 재귀함수
-> call stack 에 함수 계속 쌓임. 이 공간이 가득 차면 stack overflow 발생
-> 무한히 반복되는 재귀 호출을 막기 위해 base case 필요 : 재귀함수 앞쪽에 두는 것이 좋겠다.
  : if (조건) : return 으로 함수 stop 가능

# 파이썬의 이름 찾기 규칙 (LEGB)
1. Local : 함수 내부
2. Enclosed : 부모함수 내부
3. Global : 함수 외부 (전역 변수)
4. Built-in : 파이썬 내장 함수들
- 즉, 함수 내부에서 어떤 변수가 없으면 그것을 부모함수, 외부 등에서 찾아서 사용한다
- 이 때는 Read 만 가능하며, Write 를 하고 싶다면 global 로 선언을 해주어야 한다.


# 2751
_, *num = map(int,sys.stdin.read().split())
1) read() 를 사용하면 처음부터 끝까지 모두 읽어올 수 있음
-> VS Code 에서 해보면 이게 끝이 안나므로 Input 붙여넣기 다 한 뒤에 엔터 누르고 ctrl+Z 후 Enter 눌러줘야 함.
2) _는 첫번째 값을 저장한 것이고, 그 뒤의 값들은 *num 을 활용하여 num 에 리스트로 저장
# print(*sorted(num), sep='\n')
1) num 이 리스트니까 이걸 sorted 한거를 unpacking 해서 print 하는데, 이때 구분자를 \n 으로 한다.


# 10989
C언어에서 정수 하나는 딱 4바이트 공간만 차지한다.
하지만 파이썬의 모든 것은 객체로 동작하기 때문에, 
정수 객체를 만들면 참조 횟수, 타입 정보, 값의 크기, 실제 숫자 값이 같이 저장된다.
따라서.. 파이썬에서 가장 작은 정수 하나가 차지하는 메모리는 약 28바이트..!
심지어 리스트를 만들면 리스트 자체도 메모리를 사용한다. 한칸당 8바이트라고 생각하면 됨
그럼 1000만개의 정수를 담은 리스트라면.. 36바이트*1000만..

그래서 이 문제는 카운팅 정렬을 사용한다.
count = [0 for _ in range(10001)] 로 만든 뒤에 input 으로 받은 값의 갯수만을 세어 저장하는 것!
그리고 나중에 다시 count 를 기반으로 데이터를 조작하면 된다..



**** 다음 시간 복습 필요한 문항 : 2751, 10989